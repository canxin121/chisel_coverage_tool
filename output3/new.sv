// Generated by CIRCT firtool-1.62.1
module SimpleFsm (
    input        clock,
    reset,
    io_start,
    input  [7:0] io_dataIn,
    output       io_busy,
    output [7:0] io_dataOut,
    output       io_done,
    _cond_pred_SimpleFsm__I__local__I___T_2,
    _cond_pred_SimpleFsm__I__local__I___T_5,
    _cond_pred_SimpleFsm__I__local__I___T_6,
    _cond_pred_SimpleFsm__I__local__I___T_9,
    _cond_pred_SimpleFsm__I__local__I__io__S__start
);

  reg  [1:0] currentState;
  reg  [3:0] counter;
  wire       _cond_pred_SimpleFsm__I__local__I___T_2_0 = currentState == 2'h0;
  wire       _GEN = currentState == 2'h1;
  wire       _GEN_0 = counter < 4'h5;
  wire       io_done_0 = ~(_cond_pred_SimpleFsm__I__local__I___T_2_0 | _GEN) & currentState == 2'h2;
  always @(posedge clock) begin
    if (reset) begin
      currentState <= 2'h0;
      counter <= 4'h0;
    end else begin
      automatic
      logic [3:0][1:0]
      _GEN_1 = {
        {currentState}, {2'h0}, {_GEN_0 ? 2'h1 : 2'h2}, {io_start ? 2'h1 : currentState}
      };
      currentState <= _GEN_1[currentState];
      if (_cond_pred_SimpleFsm__I__local__I___T_2_0) begin
        if (io_start) counter <= 4'h0;
      end else if (_GEN) begin
        if (_GEN_0) counter <= counter + 4'h1;
        else counter <= 4'h0;
      end
    end
  end  // always @(posedge)
  assign io_busy = |currentState;
  assign io_dataOut = 8'h0;
  assign io_done = io_done_0;
  assign _cond_pred_SimpleFsm__I__local__I___T_2 = _cond_pred_SimpleFsm__I__local__I___T_2_0;
  assign _cond_pred_SimpleFsm__I__local__I___T_5 =
    ~_cond_pred_SimpleFsm__I__local__I___T_2_0 & _GEN;
  assign _cond_pred_SimpleFsm__I__local__I___T_6 =
    ~_cond_pred_SimpleFsm__I__local__I___T_2_0 & _GEN & _GEN_0;
  assign _cond_pred_SimpleFsm__I__local__I___T_9 = io_done_0;
  assign _cond_pred_SimpleFsm__I__local__I__io__S__start = io_start;
endmodule

