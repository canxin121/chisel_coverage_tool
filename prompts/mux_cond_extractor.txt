// SPDX-License-Identifier: Apache-2.0

package firrtl
package ir

import firrtl.annotations.Annotation

import dataclass.{data, since}
import org.apache.commons.text.translate.{AggregateTranslator, JavaUnicodeEscaper, LookupTranslator}

import scala.collection.JavaConverters._

/** Intermediate Representation */
abstract class FirrtlNode {
  def serialize: String
}

/** Use the [[firrtl.ir.Serializer]] to serialize this node. */
private[firrtl] trait UseSerializer extends FirrtlNode {
  def serialize: String = Serializer.serialize(this)
}

abstract class Info extends FirrtlNode with UseSerializer
case object NoInfo extends Info {
  override def toString: String = ""
}

/** Stores the string of a file info annotation in its escaped form. */
case class FileInfo(escaped: String) extends Info {
  override def toString: String = " @[" + escaped + "]"
  def unescaped:         String = FileInfo.unescape(escaped)
  def split:             (String, String, String) = FileInfo.split(escaped)
}

object FileInfo {
  def fromEscaped(s:   String): FileInfo = new FileInfo(s)
  def fromUnescaped(s: String): FileInfo = new FileInfo(escape(s))

  /** prepends a `\` to: `\`, `\n`, `\t` and `]` */
  def escape(s: String): String = {
    // Only run translator if String contains a character needing escaping,
    // Speeds up common case
    if (s.exists(char => escapePairs.contains(char))) {
      EscapeFirrtl.translate(s)
    } else {
      s
    }
  }

  /** removes the `\` in front of `\`, `\n`, `\t` and `]` */
  def unescape(s: String): String = {
    // Only run translator if String contains '\' which implies something needs unescaping
    // Speeds up common case
    if (s.contains('\\')) {
      UnescapeFirrtl.translate(s)
    } else {
      s
    }
  }

  /** take an already escaped String and do the additional escaping needed for Verilog comment */
  def escapedToVerilog(s: String) = EscapedToVerilog.translate(s)

  // custom `CharSequenceTranslator` for FIRRTL Info String escaping
  type CharMap = (CharSequence, CharSequence)
  private val escapePairs: Map[Char, String] = Map(
    '\\' -> "\\\\",
    '\n' -> "\\n",
    '\t' -> "\\t",
    ']' -> "\\]"
  )
  // Helper for constructing the LookupTranslators
  private def escapePairsCharSeq: Map[CharSequence, CharSequence] = escapePairs.map { case (k, v) => k.toString -> v }

  private val EscapeFirrtl = new LookupTranslator(escapePairsCharSeq.asJava)
  private val UnescapeFirrtl = new LookupTranslator(escapePairsCharSeq.map(_.swap).asJava)

  // EscapeFirrtl + EscapedToVerilog essentially does the same thing as running StringEscapeUtils.unescapeJava
  private val EscapedToVerilog = new AggregateTranslator(
    new LookupTranslator(
      Seq[CharMap](
        // ] is the one character that firrtl needs to be escaped that does not need to be escaped in
        "\\]" -> "]",
        "\"" -> "\\\"",
        // \n and \t are already escaped
        "\b" -> "\\b",
        "\f" -> "\\f",
        "\r" -> "\\r"
      ).toMap.asJava
    ),
    JavaUnicodeEscaper.outsideOf(32, 0x7f)
  )

  // Splits the FileInfo into its corresponding file, line, and column strings
  private def split(s: String): (String, String, String) = {
    s match {
      // Yield the three
      case FileInfoRegex(file, line, col) => (file, line, col)
      // Otherwise, just return the string itself and null for the other values
      case _ => (s, null, null)
    }
  }

  private val FileInfoRegex = """(?:([^\s]+)(?: (\d+)\:(\d+)))""".r
}

trait HasName {
  val name: String
}
trait HasInfo {
  val info: Info
}
trait IsDeclaration extends HasName with HasInfo

case class StringLit(string: String) extends FirrtlNode {
  import org.apache.commons.text.StringEscapeUtils

  /** Returns an escaped and quoted String */
  def escape: String = {
    "\"" + serialize + "\""
  }
  def serialize: String = StringEscapeUtils.escapeJava(string)

  /** Format the string for Verilog */
  def verilogFormat: StringLit = {
    StringLit(string.replaceAll("%x", "%h"))
  }

  /** Returns an escaped and quoted String */
  def verilogEscape: String = {
    // normalize to turn things like ö into o
    import java.text.Normalizer
    val normalized = Normalizer.normalize(string, Normalizer.Form.NFD)
    val ascii = normalized.flatMap(StringLit.toASCII)
    ascii.mkString("\"", "", "\"")
  }
}
object StringLit {
  import org.apache.commons.text.StringEscapeUtils

  /** Maps characters to ASCII for Verilog emission */
  private def toASCII(char: Char): List[Char] = char match {
    case nonASCII if !nonASCII.isValidByte => List('?')
    case '"'                               => List('\\', '"')
    case '\\'                              => List('\\', '\\')
    case c if c >= ' ' && c <= '~'         => List(c)
    case '\n'                              => List('\\', 'n')
    case '\t'                              => List('\\', 't')
    case _                                 => List('?')
  }

  /** Create a StringLit from a raw parsed String */
  def unescape(raw: String): StringLit = {
    StringLit(StringEscapeUtils.unescapeJava(raw))
  }
}

/** Primitive Operation
  *
  * See [[PrimOps]]
  */
abstract class PrimOp extends FirrtlNode {
  def serialize: String = this.toString
  def apply(args: Any*): DoPrim = {
    val groups = args.groupBy {
      case x: Expression => "exp"
      case x: BigInt     => "int"
      case x: Int        => "int"
      case other => "other"
    }
    val exprs = groups.getOrElse("exp", Nil).collect {
      case e: Expression => e
    }
    val consts = groups.getOrElse("int", Nil).map {
      _ match {
        case i: BigInt => i
        case i: Int    => BigInt(i)
      }
    }
    groups.get("other") match {
      case None    =>
      case Some(x) => sys.error(s"Shouldn't be here: $x")
    }
    DoPrim(this, exprs, consts, UnknownType)
  }
}

abstract class Expression extends FirrtlNode {
  def tpe: Type
}

case class Reference(name: String, tpe: Type = UnknownType) extends Expression with HasName with UseSerializer

case class SubField(expr: Expression, name: String, tpe: Type = UnknownType)
    extends Expression
    with HasName
    with UseSerializer

case class SubIndex(expr: Expression, value: Int, tpe: Type) extends Expression with UseSerializer

case class SubAccess(expr: Expression, index: Expression, tpe: Type) extends Expression with UseSerializer

case class Mux(cond: Expression, tval: Expression, fval: Expression, tpe: Type = UnknownType)
    extends Expression
    with UseSerializer
case class ValidIf(cond: Expression, value: Expression, tpe: Type) extends Expression with UseSerializer
abstract class Literal extends Expression {
  val value: BigInt
  val width: Width
}
case class UIntLiteral(value: BigInt, width: Width) extends Literal with UseSerializer {
  def tpe = UIntType(width)
}
object UIntLiteral {
  def minWidth(value: BigInt): Width = IntWidth(math.max(value.bitLength, 1))
  def apply(value:    BigInt): UIntLiteral = new UIntLiteral(value, minWidth(value))

  /** Utility to construct UIntLiterals masked by the width
    *
    * This supports truncating negative values as well as values that are too wide for the width
    */
  def masked(value: BigInt, width: IntWidth): UIntLiteral = {
    val mask = (BigInt(1) << width.width.toInt) - 1
    UIntLiteral(value & mask, width)
  }
}
case class SIntLiteral(value: BigInt, width: Width) extends Literal with UseSerializer {
  def tpe = SIntType(width)
}
object SIntLiteral {
  def minWidth(value: BigInt): Width = IntWidth(value.bitLength + 1)
  def apply(value:    BigInt): SIntLiteral = new SIntLiteral(value, minWidth(value))
}

case class IntegerPropertyLiteral(value: BigInt) extends Literal with UseSerializer {
  def tpe = IntegerPropertyType
  val width = UnknownWidth
}

case class DoublePropertyLiteral(value: Double) extends Expression with UseSerializer {
  def tpe = DoublePropertyType
  val width = UnknownWidth
}

case class StringPropertyLiteral(value: String) extends Expression with UseSerializer {
  def tpe = StringPropertyType
  val width = UnknownWidth
}

case class BooleanPropertyLiteral(value: Boolean) extends Expression with UseSerializer {
  val tpe = BooleanPropertyType
}

case class PathPropertyLiteral(value: String) extends Expression with UseSerializer {
  val tpe = PathPropertyType
}

case class SequencePropertyValue(tpe: Type, values: Seq[Expression]) extends Expression with UseSerializer

/** Property primitive operations.
  */
sealed abstract class PropPrimOp(name: String) {
  override def toString: String = name
}
case object IntegerAddOp extends PropPrimOp("integer_add")
case object IntegerMulOp extends PropPrimOp("integer_mul")
case object IntegerShrOp extends PropPrimOp("integer_shr")

/** Property expressions.
  *
  * Unlike other primitives, Property expressions serialize as a tree directly in their rvalue context.
  */
case class PropExpr(info: Info, tpe: Type, op: PropPrimOp, args: Seq[Expression])
    extends Expression
    with UseSerializer {
  override def serialize: String = {
    val serializedOp = op.toString()
    val serializedArgs = args.map(_.serialize).mkString("(", ", ", ")")
    serializedOp + serializedArgs
  }
}

case class DoPrim(op: PrimOp, args: Seq[Expression], consts: Seq[BigInt], tpe: Type)
    extends Expression
    with UseSerializer

abstract class Statement extends FirrtlNode
case class DefWire(info: Info, name: String, tpe: Type) extends Statement with IsDeclaration with UseSerializer
case class DefRegister(
  info:  Info,
  name:  String,
  tpe:   Type,
  clock: Expression)
    extends Statement
    with IsDeclaration
    with UseSerializer
case class DefRegisterWithReset(
  info:  Info,
  name:  String,
  tpe:   Type,
  clock: Expression,
  reset: Expression,
  init:  Expression)
    extends Statement
    with IsDeclaration
    with UseSerializer

object DefInstance {
  def apply(name: String, module: String): DefInstance = DefInstance(NoInfo, name, module)
}

case class DefInstance(info: Info, name: String, module: String, tpe: Type = UnknownType)
    extends Statement
    with IsDeclaration
    with UseSerializer

case class DefInstanceChoice(
  info:    Info,
  name:    String,
  default: String,
  option:  String,
  choices: Seq[(String, String)])
    extends Statement
    with IsDeclaration
    with UseSerializer

case class DefObject(info: Info, name: String, cls: String) extends Statement with IsDeclaration with UseSerializer

object ReadUnderWrite extends Enumeration {
  val Undefined = Value("undefined")
  val Old = Value("old")
  val New = Value("new")
}

case class DefMemory(
  info:         Info,
  name:         String,
  dataType:     Type,
  depth:        BigInt,
  writeLatency: Int,
  readLatency:  Int,
  readers:      Seq[String],
  writers:      Seq[String],
  readwriters:  Seq[String],
  // TODO: handle read-under-write
  readUnderWrite: ReadUnderWrite.Value = ReadUnderWrite.Undefined)
    extends Statement
    with IsDeclaration
    with UseSerializer
case class DefNode(info: Info, name: String, value: Expression) extends Statement with IsDeclaration with UseSerializer

/** Record/bundle type definition that names a FIRRTL type with an alias name */
case class DefTypeAlias(info: Info, name: String, tpe: Type) extends Statement with UseSerializer

case class Conditionally(
  info:   Info,
  pred:   Expression,
  conseq: Statement,
  alt:    Statement)
    extends Statement
    with HasInfo
    with UseSerializer

object Block {
  def apply(head: Statement, tail: Statement*): Block = Block(head +: tail)
}

case class Block(stmts: Seq[Statement]) extends Statement with UseSerializer
case class Connect(info: Info, loc: Expression, expr: Expression) extends Statement with HasInfo with UseSerializer
case class PropAssign(info: Info, loc: Expression, expr: Expression) extends Statement with HasInfo with UseSerializer
case class IsInvalid(info: Info, expr: Expression) extends Statement with HasInfo with UseSerializer
case class Attach(info: Info, exprs: Seq[Expression]) extends Statement with HasInfo with UseSerializer

@data class Stop(info: Info, ret: Int, clk: Expression, en: Expression, @since("FIRRTL 1.5") name: String = "")
    extends Statement
    with HasInfo
    with IsDeclaration
    with UseSerializer {
  def copy(info: Info = info, ret: Int = ret, clk: Expression = clk, en: Expression = en): Stop = {
    Stop(info, ret, clk, en, name)
  }
}
object Stop {
  def unapply(s: Stop): Some[(Info, Int, Expression, Expression)] = {
    Some((s.info, s.ret, s.clk, s.en))
  }
}
@data class Print(
  info:   Info,
  string: StringLit,
  args:   Seq[Expression],
  clk:    Expression,
  en:     Expression,
  @since("FIRRTL 1.5")
  name: String = "")
    extends Statement
    with HasInfo
    with IsDeclaration
    with UseSerializer {
  def copy(
    info:   Info = info,
    string: StringLit = string,
    args:   Seq[Expression] = args,
    clk:    Expression = clk,
    en:     Expression = en
  ): Print = {
    Print(info, string, args, clk, en, name)
  }
}
object Print {
  def unapply(s: Print): Some[(Info, StringLit, Seq[Expression], Expression, Expression)] = {
    Some((s.info, s.string, s.args, s.clk, s.en))
  }
}

case class ProbeDefine(info: Info, sink: Expression, probeExpr: Expression) extends Statement with UseSerializer
case class ProbeExpr(expr: Expression, tpe: Type = UnknownType) extends Expression with UseSerializer

case class RWProbeExpr(expr: Expression, tpe: Type = UnknownType) extends Expression with UseSerializer
case class ProbeRead(expr: Expression, tpe: Type = UnknownType) extends Expression with UseSerializer

case class ProbeForceInitial(info: Info, probe: Expression, value: Expression) extends Statement with UseSerializer
case class ProbeReleaseInitial(info: Info, probe: Expression) extends Statement with UseSerializer
case class ProbeForce(info: Info, clock: Expression, cond: Expression, probe: Expression, value: Expression)
    extends Statement
    with UseSerializer
case class ProbeRelease(info: Info, clock: Expression, cond: Expression, probe: Expression)
    extends Statement
    with UseSerializer

object LayerConvention {
  sealed trait Type
  case object Bind extends Type {
    override def toString: String = "bind"
  }
}

case class Layer(info: Info, name: String, convention: LayerConvention.Type, body: Seq[Layer])
    extends FirrtlNode
    with IsDeclaration
    with UseSerializer
case class LayerBlock(info: Info, layer: String, body: Statement) extends Statement with UseSerializer

// option and case
case class DefOption(info: Info, name: String, cases: Seq[DefOptionCase])
case class DefOptionCase(info: Info, name: String)

// formal
object Formal extends Enumeration {
  val Assert = Value("assert")
  val Assume = Value("assume")
  val Cover = Value("cover")
}

@data class Verification(
  op:   Formal.Value,
  info: Info,
  clk:  Expression,
  pred: Expression,
  en:   Expression,
  msg:  StringLit,
  @since("FIRRTL 1.5")
  name: String = "")
    extends Statement
    with HasInfo
    with IsDeclaration
    with UseSerializer {
  def copy(
    op:   Formal.Value = op,
    info: Info = info,
    clk:  Expression = clk,
    pred: Expression = pred,
    en:   Expression = en,
    msg:  StringLit = msg
  ): Verification = {
    Verification(op, info, clk, pred, en, msg, name)
  }
}
object Verification {
  def unapply(s: Verification): Some[(Formal.Value, Info, Expression, Expression, Expression, StringLit)] = {
    Some((s.op, s.info, s.clk, s.pred, s.en, s.msg))
  }
}
// end formal

case object EmptyStmt extends Statement with UseSerializer

abstract class Width extends FirrtlNode {
  def +(x: Width): Width = (this, x) match {
    case (a: IntWidth, b: IntWidth) => IntWidth(a.width + b.width)
    case _ => UnknownWidth
  }
  def -(x: Width): Width = (this, x) match {
    case (a: IntWidth, b: IntWidth) => IntWidth(a.width - b.width)
    case _ => UnknownWidth
  }
  def max(x: Width): Width = (this, x) match {
    case (a: IntWidth, b: IntWidth) => IntWidth(a.width.max(b.width))
    case _ => UnknownWidth
  }
  def min(x: Width): Width = (this, x) match {
    case (a: IntWidth, b: IntWidth) => IntWidth(a.width.min(b.width))
    case _ => UnknownWidth
  }
}

/** Positive Integer Bit Width of a [[GroundType]] */
object IntWidth {
  private val maxCached = 1024
  private val cache = new Array[IntWidth](maxCached + 1)
  def apply(width: BigInt): IntWidth = {
    if (0 <= width && width <= maxCached) {
      val i = width.toInt
      var w = cache(i)
      if (w eq null) {
        w = new IntWidth(width)
        cache(i) = w
      }
      w
    } else new IntWidth(width)
  }
  // For pattern matching
  def unapply(w: IntWidth): Option[BigInt] = Some(w.width)
}
class IntWidth(val width: BigInt) extends Width with Product with UseSerializer {
  override def equals(that: Any) = that match {
    case w: IntWidth => width == w.width
    case _ => false
  }
  override def hashCode = width.toInt
  override def productPrefix = "IntWidth"
  override def toString = s"$productPrefix($width)"
  def copy(width:    BigInt = width) = IntWidth(width)
  def canEqual(that: Any) = that.isInstanceOf[Width]
  def productArity = 1
  def productElement(int: Int) = int match {
    case 0 => width
    case _ => throw new IndexOutOfBoundsException
  }
}
case object UnknownWidth extends Width with UseSerializer

/** Orientation of [[Field]] */
abstract class Orientation extends FirrtlNode
case object Default extends Orientation {
  def serialize: String = ""
}
case object Flip extends Orientation {
  def serialize: String = "flip "
}

/** Field of [[BundleType]] */
case class Field(name: String, flip: Orientation, tpe: Type) extends FirrtlNode with HasName with UseSerializer

/** Types of [[FirrtlNode]] */
abstract class Type extends FirrtlNode
abstract class GroundType extends Type {
  val width: Width
}
object GroundType {
  def unapply(ground: GroundType): Option[Width] = Some(ground.width)
}
abstract class AggregateType extends Type

case class ProbeType(underlying: Type) extends Type with UseSerializer
case class RWProbeType(underlying: Type) extends Type with UseSerializer

case class ConstType(underlying: Type) extends Type with UseSerializer

case class UIntType(width: Width) extends GroundType with UseSerializer
case class SIntType(width: Width) extends GroundType with UseSerializer

case class BundleType(fields: Seq[Field]) extends AggregateType with UseSerializer
case class VectorType(tpe: Type, size: Int) extends AggregateType with UseSerializer
case object ClockType extends GroundType with UseSerializer {
  val width = IntWidth(1)
}
/* Abstract reset, will be inferred to UInt<1> or AsyncReset */
case object ResetType extends GroundType with UseSerializer {
  val width = IntWidth(1)
}
case object AsyncResetType extends GroundType with UseSerializer {
  val width = IntWidth(1)
}
case class AnalogType(width: Width) extends GroundType with UseSerializer

case class AliasType(name: String) extends Type with UseSerializer

sealed abstract class PropertyType extends Type with UseSerializer

case object IntegerPropertyType extends PropertyType

case object DoublePropertyType extends PropertyType

case object StringPropertyType extends PropertyType

case object BooleanPropertyType extends PropertyType

case object PathPropertyType extends PropertyType

case class SequencePropertyType(tpe: PropertyType) extends PropertyType

case class ClassPropertyType(name: String) extends PropertyType

case object AnyRefPropertyType extends PropertyType

case object UnknownType extends Type with UseSerializer

/** [[Port]] Direction */
sealed abstract class Direction extends FirrtlNode
case object Input extends Direction {
  def serialize: String = "input"
}
case object Output extends Direction {
  def serialize: String = "output"
}

/** [[DefModule]] Port */
case class Port(
  info:      Info,
  name:      String,
  direction: Direction,
  tpe:       Type)
    extends FirrtlNode
    with IsDeclaration
    with UseSerializer

/** Parameters for external modules */
sealed abstract class Param extends FirrtlNode {
  def name: String
}

/** Integer (of any width) Parameter */
case class IntParam(name: String, value: BigInt) extends Param with UseSerializer

/** IEEE Double Precision Parameter (for Verilog real) */
case class DoubleParam(name: String, value: Double) extends Param with UseSerializer

/** String Parameter */
case class StringParam(name: String, value: StringLit) extends Param with UseSerializer

/** Raw String Parameter
  * Useful for Verilog type parameters
  * @note Firrtl doesn't guarantee anything about this String being legal in any backend
  */
case class RawStringParam(name: String, value: String) extends Param with UseSerializer

/** Base class for modules */
abstract class DefModule extends FirrtlNode with IsDeclaration {
  val info:  Info
  val name:  String
  val ports: Seq[Port]
}

/** Internal Module
  *
  * An instantiable hardware block
  */
case class Module(info: Info, name: String, ports: Seq[Port], body: Statement) extends DefModule with UseSerializer

/** External Module
  *
  * Generally used for Verilog black boxes
  * @param defname Defined name of the external module (ie. the name Firrtl will emit)
  */
case class ExtModule(
  info:    Info,
  name:    String,
  ports:   Seq[Port],
  defname: String,
  params:  Seq[Param])
    extends DefModule
    with UseSerializer

/** Intrinsic Module
  *
  * Used for compiler intrinsics.
  * @param intrinsic Defined intrinsic of the module
  */
case class IntModule(
  info:      Info,
  name:      String,
  ports:     Seq[Port],
  intrinsic: String,
  params:    Seq[Param])
    extends DefModule
    with UseSerializer

/** Class definition
  */
case class DefClass(info: Info, name: String, ports: Seq[Port], body: Statement) extends DefModule with UseSerializer

case class Circuit(
  info:        Info,
  modules:     Seq[DefModule],
  main:        String,
  typeAliases: Seq[DefTypeAlias] = Seq.empty,
  layers:      Seq[Layer] = Seq.empty,
  options:     Seq[DefOption] = Seq.empty)
    extends FirrtlNode
    with HasInfo
    with UseSerializer

case class CircuitWithAnnos(circuit: Circuit, annotations: Seq[Annotation]) extends FirrtlNode with UseSerializer 以上是源代码;
下面是我的一些class和方法:

package firrtl
package ir

import dataclass.{data, since}
import org.apache.commons.text.translate.{
  AggregateTranslator,
  JavaUnicodeEscaper,
  LookupTranslator
}
import scala.collection.JavaConverters._
import scala.collection.mutable

// --- Circe 库的导入 ---
import io.circe._ // 核心 Circe 类型 (Json, Encoder, Decoder)
import io.circe.generic.auto._ // 为 case class 自动派生 Encoder/Decoder
import io.circe.parser._ // 用于解析 JSON 字符串 (decode)
import io.circe.syntax._ // 提供 .asJson 等语法糖

@data // 假设使用了 dataclass 注解，否则移除
case class InstTree(
    inst_name: String,
    module_name: String,
    sub_inst: List[InstTree] // 递归结构
) {
  def toJson(
      prettyPrint: Boolean = false
  ): String = InstTree.toJson(this, prettyPrint)
}

object InstTree {

  // --- 源自你提供的原始代码 ---

  private def findInstances(stmt: Statement): List[DefInstance] = {
    val instances = mutable.ListBuffer[DefInstance]()
    def rec(s: Statement): Unit = s match {
      case inst: DefInstance => instances += inst
      // case choice: DefInstanceChoice => // 如果需要可以处理
      case Block(stmts) => stmts.foreach(rec)
      case Conditionally(_, _, conseq, alt) =>
        rec(conseq)
        rec(alt)
      // 明确处理已知的、不直接包含实例定义的语句类型
      case _: Print | _: Verification | EmptyStmt | _: Connect | _: IsInvalid |
          _: DefWire | _: DefRegister | _: DefMemory | _: DefNode | _: Stop |
          _: Attach =>
        ()
      // 对于未明确处理的语句类型，可以添加警告或默认处理
      // case other => System.err.println(s"警告：在 findInstances 中遇到未处理的语句类型: ${other.getClass.getSimpleName}")
    }
    rec(stmt)
    instances.toList
  }

  private def buildInstTreeRecursive(
      current_inst_name: String,
      current_module_name: String,
      moduleMap: Map[String, DefModule]
  ): Option[InstTree] = {
    moduleMap.get(current_module_name) match {
      case Some(module: Module) =>
        val directSubInstances = findInstances(module.body)
        // 对每个直接子实例递归构建树
        val subInsts = directSubInstances.flatMap { subDef =>
          // 使用子实例名(subDef.name)和子模块名(subDef.module)进行递归
          buildInstTreeRecursive(subDef.name, subDef.module, moduleMap)
        }
        Some(InstTree(current_inst_name, current_module_name, subInsts))

      case Some(ext: ExtModule) => // 外部模块是叶子节点
        Some(InstTree(current_inst_name, current_module_name, List.empty))

      case Some(int: IntModule) => // 固有模块也是叶子节点
        Some(InstTree(current_inst_name, current_module_name, List.empty))

      case Some(cls: DefClass) => // 类定义可能包含实例，处理逻辑类似 Module
        val directSubInstances = findInstances(cls.body)
        val subInsts = directSubInstances.flatMap { subDef =>
          buildInstTreeRecursive(subDef.name, subDef.module, moduleMap)
        }
        Some(InstTree(current_inst_name, current_module_name, subInsts))

      case Some(other: DefModule) => // 处理其他未明确覆盖的 DefModule 子类
        System.err.println(
          s"警告：遇到未明确处理的模块类型 '${other.getClass.getName}' (模块名: '$current_module_name')。"
        )
        Some(
          InstTree(current_inst_name, current_module_name, List.empty)
        ) // 当作叶子节点处理

      case None => // 未找到模块定义
        System.err.println(s"警告：找不到模块 '$current_module_name' 的定义。")
        None // 返回 None 表示构建失败
    }
  }

  /** 根据给定的电路(Circuit)构建实例树(Inst)。
    *
    * @param circuit
    *   FIRRTL 电路对象。
    * @param topInstName
    *   顶层实例的名称，默认为 "mainInst"。
    * @return
    *   如果成功构建，返回 Option[Inst]，否则返回 None (例如，如果主模块未找到)。
    */
  def apply(
      circuit: Circuit,
      topInstName: String = "mainInst" // 如果需要，提供默认值
  ): Option[InstTree] = {
    // 创建一个从模块名到模块定义的映射，方便查找
    val moduleMap = circuit.modules.map(m => m.name -> m).toMap
    // 从主模块 (circuit.main) 开始递归构建
    buildInstTreeRecursive(topInstName, circuit.main, moduleMap)
  }

  // --- JSON 序列化/反序列化方法 ---

  /** 将一个 Inst 对象序列化为 JSON 字符串。
    *
    * @param inst
    *   要序列化的 Inst 对象。
    * @param prettyPrint
    *   如果为 true，则格式化 JSON（带缩进和换行），默认为 false（紧凑格式）。
    * @return
    *   Inst 对象的 JSON 字符串表示。
    */
  def toJson(inst: InstTree, prettyPrint: Boolean = false): String = {
    // .asJson 需要一个作用域内的隐式 Encoder[Inst]。
    // io.circe.generic.auto._ 会自动提供这个 Encoder。
    val jsonAst: Json = inst.asJson
    if (prettyPrint) {
      jsonAst.spaces2 // 或者 jsonAst.spaces4 使用4空格缩进
    } else {
      jsonAst.noSpaces // 生成无空格的紧凑 JSON
    }
  }

  /** 将一个 JSON 字符串反序列化为一个 Inst 对象。
    *
    * @param jsonString
    *   要反序列化的 JSON 字符串。
    * @return
    *   返回一个 Either 类型：
    *   - 如果解析或解码失败，返回 Left(io.circe.Error)。
    *   - 如果成功，返回 Right(Inst)。
    */
  def fromJson(jsonString: String): Either[Error, InstTree] = {
    // parse 函数尝试将字符串解析为 Circe 的 Json AST (抽象语法树)
    // 它返回 Either[ParsingFailure, Json]
    // .flatMap 用于链式操作：只有当 parse 成功时，才执行后续的解码操作
    // .as[Inst] 尝试将 Json AST 解码为一个 Inst 对象
    // 它需要一个作用域内的隐式 Decoder[Inst] (由 generic.auto._ 提供)
    // 它返回 Either[DecodingFailure, Inst]
    // 最终结果是 Either[Error, Inst]，其中 Error 是 ParsingFailure 和 DecodingFailure 的父类型
    parse(jsonString).flatMap(_.as[InstTree])
  }

  /** 可选方法：将 JSON 字符串反序列化为 Option[Inst]。 如果你只关心成功或失败，而不关心具体的错误信息，这个版本更简单。
    *
    * @param jsonString
    *   要反序列化的 JSON 字符串。
    * @return
    *   如果成功，返回 Some(Inst)，否则返回 None。
    */
  def fromJsonOpt(jsonString: String): Option[InstTree] = {
    fromJson(jsonString).toOption // 将 Either[Error, Inst] 转换为 Option[Inst]
  }

}

// === 使用示例 ===
// (可以将此代码放在 firrtl 包之外，例如测试代码或主应用程序中)
/*
import firrtl.ir._
// 如果需要创建测试用的 Circuit, Module 等，也需要导入 firrtl._
// import firrtl._

object JsonExample extends App {

  // 1. 创建一个示例 Inst 层次结构 (或者从一个 Circuit 对象生成)
  //    为了简单起见，这里手动创建：
  val subSubInst = Inst("subSub1", "LeafModule", List.empty)
  val subInst1 = Inst("sub1", "MiddleModule", List(subSubInst))
  val subInst2 = Inst("sub2", "AnotherLeaf", List.empty)
  val topInst = Inst("top", "TopModule", List(subInst1, subInst2))

  // 2. 序列化为 JSON
  val jsonStringCompact = Inst.toJson(topInst)
  val jsonStringPretty = Inst.toJson(topInst, prettyPrint = true)

  println("--- 紧凑 JSON ---")
  println(jsonStringCompact)
  // 预期输出 (大致): {"inst_name":"top","module_name":"TopModule","sub_inst":[{"inst_name":"sub1","module_name":"MiddleModule","sub_inst":[{"inst_name":"subSub1","module_name":"LeafModule","sub_inst":[]}]},{"inst_name":"sub2","module_name":"AnotherLeaf","sub_inst":[]}]}

  println("\n--- 格式化 JSON ---")
  println(jsonStringPretty)
  /* 预期输出 (大致):
  {
    "inst_name" : "top",
    "module_name" : "TopModule",
    "sub_inst" : [
      {
        "inst_name" : "sub1",
        "module_name" : "MiddleModule",
        "sub_inst" : [
          {
            "inst_name" : "subSub1",
            "module_name" : "LeafModule",
            "sub_inst" : [
            ]
          }
        ]
      },
      {
        "inst_name" : "sub2",
        "module_name" : "AnotherLeaf",
        "sub_inst" : [
        ]
      }
    ]
  }
 */


  // 3. 从 JSON 反序列化
  val deserializedEither: Either[Error, Inst] = Inst.fromJson(jsonStringCompact)

  deserializedEither match {
    case Right(inst) =>
      println("\n--- 反序列化成功 ---")
      println(inst)
      assert(inst == topInst) // 验证反序列化得到的对象与原始对象相同
      println("验证成功：反序列化对象与原始对象匹配。")
    case Left(error) =>
      println(s"\n--- 反序列化失败 ---")
      println(s"错误: $error")
  }

  // 使用 Option 版本的示例
  val deserializedOpt: Option[Inst] = Inst.fromJsonOpt(jsonStringCompact)
  println(s"\n--- 反序列化 (Option 版本) ---")
  // 使用 getOrElse 提供一个失败时的默认值
  println(deserializedOpt.getOrElse("反序列化失败"))

  // 反序列化失败的示例
  val badJson = """{"inst_name":"bad", "module_name":"BadModule", "sub_inst": "not_a_list"}""" // sub_inst 应该是列表，这里是字符串
  val failedDeserialization = Inst.fromJson(badJson)
  println(s"\n--- 尝试反序列化无效 JSON ---")
  failedDeserialization match {
    case Right(_) => println("意外成功！这不应该发生。")
    case Left(error) => println(s"符合预期的失败: $error") // 应该打印出解码错误信息
  }

}
 */

package firrtl
package ir

// 导入 InstTree 类定义 (假设它在同一个包或已导入)
// import firrtl.ir.InstTree // 如果不在同一文件

import dataclass.data // 假设使用了 dataclass 注解
import io.circe._ // 核心 Circe 类型
import io.circe.generic.auto._ // 自动派生 Encoder/Decoder
import io.circe.parser._ // JSON 解析
import io.circe.syntax._ // .asJson 语法糖

/** 表示模块的层级依赖关系树。 与 InstTree 不同，ModuleTree 不包含实例名，并且对于同一父模块
  * 下实例化的多个相同类型的子模块，只在树中表示一次。
  *
  * @param module_name
  *   当前节点的模块名称。
  * @param sub_modules
  *   一个列表，包含此模块直接实例化的 *不同类型* 的子模块所对应的 ModuleTree。
  */
@data // 假设使用了 dataclass 注解，否则移除
case class ModuleTree(
    module_name: String,
    sub_modules: List[ModuleTree]
) {

  /** 将此 ModuleTree 对象序列化为 JSON 字符串。
    * @param prettyPrint
    *   是否进行格式化（带缩进和换行），默认为 false。
    * @return
    *   JSON 字符串。
    */
  def toJson(prettyPrint: Boolean = false): String =
    ModuleTree.toJson(this, prettyPrint)
}

object ModuleTree {

  /** 从一个 InstTree (实例树) 构建 ModuleTree (模块类型树)。 这个过程会去除实例名，并合并对同一模块类型的多次实例化。
    *
    * @param instTree
    *   输入的实例树。
    * @return
    *   构建好的模块类型树。
    */
  def apply(instTree: InstTree): ModuleTree = {
    // 1. 获取当前实例树节点的模块名
    val currentModuleName = instTree.module_name

    // 2. 获取所有直接子实例
    val subInstances = instTree.sub_inst

    // 3. 找出所有直接子实例的 *唯一* 模块名
    //    并为每个唯一的子模块名选择一个代表性的子 InstTree 用于递归
    //    我们使用 groupBy 分组，然后取每组的第一个元素 (head) 作为代表
    val representativeSubInsts = subInstances
      .groupBy(_.module_name) // 按子模块名分组 Map[String, List[InstTree]]
      .map { case (_, instList) => instList.head } // 取每组的第一个实例作为代表
      .toList // 转换为列表

    // 4. 对每个代表性的子 InstTree 递归调用 fromInstTree
    val subModuleTrees = representativeSubInsts.map { subInst =>
      ModuleTree(subInst) // 递归构建子模块树
    }

    // 5. 构建并返回当前的 ModuleTree 节点
    ModuleTree(currentModuleName, subModuleTrees)
  }

  // --- JSON 序列化/反序列化方法 ---

  /** 将一个 ModuleTree 对象序列化为 JSON 字符串。
    *
    * @param moduleTree
    *   要序列化的 ModuleTree 对象。
    * @param prettyPrint
    *   如果为 true，则格式化 JSON，默认为 false。
    * @return
    *   ModuleTree 对象的 JSON 字符串表示。
    */
  def toJson(moduleTree: ModuleTree, prettyPrint: Boolean = false): String = {
    val jsonAst: Json = moduleTree.asJson // 自动派生 Encoder[ModuleTree]
    if (prettyPrint) {
      jsonAst.spaces2 // 或 jsonAst.spaces4
    } else {
      jsonAst.noSpaces
    }
  }

  /** 将一个 JSON 字符串反序列化为一个 ModuleTree 对象。
    *
    * @param jsonString
    *   要反序列化的 JSON 字符串。
    * @return
    *   返回 Either 类型：Left(错误) 或 Right(ModuleTree)。
    */
  def fromJson(jsonString: String): Either[Error, ModuleTree] = {
    parse(jsonString).flatMap(_.as[ModuleTree]) // 自动派生 Decoder[ModuleTree]
  }

  /** 可选方法：将 JSON 字符串反序列化为 Option[ModuleTree]。
    *
    * @param jsonString
    *   要反序列化的 JSON 字符串。
    * @return
    *   如果成功，返回 Some(ModuleTree)，否则返回 None。
    */
  def fromJsonOpt(jsonString: String): Option[ModuleTree] = {
    fromJson(jsonString).toOption
  }

}

package firrtl
package ir

// import scala.collection.mutable // 移除未使用的导入
import dataclass.data

/** 存储单个模块内部找到的顶层 Mux 条件信息
  * @param length
  *   条件的数量
  * @param cond
  *   条件表达式列表。注意：这里存储的是 Expression， 但在 ModuleInternalCondMap 的构建逻辑中， 确保了这些
  *   Expression 只会是 Reference 或 SubField。 下游代码如果需要区分，可以使用模式匹配。
  */
@data
case class ModuleCondInfo(
    length: Int,
    cond: List[Expression]
)

/** 存储整个电路中每个模块的内部顶层 Mux 条件信息
  * @param map
  *   一个映射，键是模块名称 (String)，值是该模块的 CondInfo
  */
@data
case class ModuleInternalCondMap(
    // key是Module name
    // value是Module的内部的Mux cond的信息
    map: Map[String, ModuleCondInfo]
)

object ModuleInternalCondMap {

  /** 分析给定的 Circuit，收集每个 Module 主体 (body) 第一层语句中 DefNode Mux 的条件 (cond) 信息。
    * 只收集条件是 Reference 或 SubField 的 Mux。
    *
    * @param circuit
    *   要分析的 FIRRTL 电路
    * @return
    *   一个 ModuleInternalCondMap，包含每个模块的 Mux 条件信息
    */
  def apply(circuit: Circuit): ModuleInternalCondMap = {
    val moduleConds: Seq[(String, ModuleCondInfo)] = circuit.modules.collect {
      case mod: Module =>
        val body = mod.body

        // *** 修改点：收集 Expression，不再需要 Left/Right 包装 ***
        val conditions: Seq[Expression] = body match {
          case Block(stmts) =>
            stmts.collect {
              // 匹配模式：DefNode -> Mux -> cond is Reference
              case DefNode(_, _, Mux(cond: Reference, _, _, _)) =>
                cond // 直接返回 cond
              // 匹配模式：DefNode -> Mux -> cond is SubField
              case DefNode(_, _, Mux(cond: SubField, _, _, _)) =>
                cond // 直接返回 cond
            }
          // Case 2: 单个 DefNode Mux
          case DefNode(_, _, Mux(cond: Reference, _, _, _)) =>
            Seq(cond) // 直接返回 cond
          case DefNode(_, _, Mux(cond: SubField, _, _, _)) =>
            Seq(cond) // 直接返回 cond
          // Case 3: 其他情况
          case _ => Seq.empty
        }

        // 创建 CondInfo，现在 cond 是 List[Expression]
        val condInfo =
          ModuleCondInfo(length = conditions.length, cond = conditions.toList)

        (mod.name, condInfo)
    }

    ModuleInternalCondMap(moduleConds.toMap)
  }
}

现在需要递归处理, 从叶子Inst开始, 给Inst添加一个新的out的reg来包含其内部的所有Mux cond和其内部子Inst包含的所有Mux cond, 逐级向顶点Inst(直接认为Circuit的main这个Module的Inst为mainInst作为顶点Inst)累加,最后顶点包含其内部Mux cond和所有子孙Inst的mux cond, 可以创建新的class和cond info啥的, 逐级记录方便上一层处理

最后要达成的效果是修改每个Module来暴露其中的Mux cond和其子孙Mux cond的端口, 最后的TopModule要能拿到其内部Mux cond和所有子孙Inst的mux cond的端口, 并且汇总的是一个reg

回答中文