// Generated by CIRCT firtool-1.51.0
module MulDiv(
  input          clock,
                 reset,
                 io_req_valid,
  input  [4:0]   io_req_bits_fn,
  input          io_req_bits_dw,
  input  [63:0]  io_req_bits_in1,
                 io_req_bits_in2,
  input  [4:0]   io_req_bits_tag,
  input          io_kill,
                 io_resp_ready,
  output         io_req_ready,
                 io_resp_valid,
  output [63:0]  io_resp_bits_data,
  output [127:0] io_resp_bits_full_data,
  output [4:0]   io_resp_bits_tag,
  output         _mux_cond_MulDiv__M__MulDiv__S___T_5,
                 _mux_cond_MulDiv__M__MulDiv__S___T_8,
                 _mux_cond_MulDiv__M__MulDiv__S___count_T_6,
                 _mux_cond_MulDiv__M__MulDiv__S___hiOut_T_1,
                 _mux_cond_MulDiv__M__MulDiv__S___hiOut_T_3,
                 _mux_cond_MulDiv__M__MulDiv__S___hi_T,
                 _mux_cond_MulDiv__M__MulDiv__S___hi_T_3,
                 _mux_cond_MulDiv__M__MulDiv__S___loOut_T_3,
                 _mux_cond_MulDiv__M__MulDiv__S___state_T_1,
                 _mux_cond_MulDiv__M__MulDiv__S__cmdHi,
                 _mux_cond_MulDiv__M__MulDiv__S__cmdMul,
                 _mux_cond_MulDiv__M__MulDiv__S__eOut,
                 _mux_cond_MulDiv__M__MulDiv__S__neg_out,
                 _mux_cond_MulDiv__M__MulDiv__S__resHi,
                 _mux_cond_MulDiv__M__MulDiv__S__unrolls_less,
                 _cond_pred_MulDiv__M__MulDiv__S___T_10,
                 _cond_pred_MulDiv__M__MulDiv__S___T_11,
                 _cond_pred_MulDiv__M__MulDiv__S___T_12,
                 _cond_pred_MulDiv__M__MulDiv__S___T_13,
                 _cond_pred_MulDiv__M__MulDiv__S___T_14,
                 _cond_pred_MulDiv__M__MulDiv__S___T_16,
                 _cond_pred_MulDiv__M__MulDiv__S___T_17,
                 _cond_pred_MulDiv__M__MulDiv__S___T_18,
                 _cond_pred_MulDiv__M__MulDiv__S___T_20,
                 _cond_pred_MulDiv__M__MulDiv__S___T_22,
                 _cond_pred_MulDiv__M__MulDiv__S___T_23,
  output [6:0]   _reg_signals_MulDiv__M__MulDiv__S__count,
  output [64:0]  _reg_signals_MulDiv__M__MulDiv__S__divisor,
  output         _reg_signals_MulDiv__M__MulDiv__S__isHi,
                 _reg_signals_MulDiv__M__MulDiv__S__neg_out,
  output [129:0] _reg_signals_MulDiv__M__MulDiv__S__remainder,
  output [4:0]   _reg_signals_MulDiv__M__MulDiv__S__req_fn,
  output         _reg_signals_MulDiv__M__MulDiv__S__req_dw,
  output [63:0]  _reg_signals_MulDiv__M__MulDiv__S__req_in1,
                 _reg_signals_MulDiv__M__MulDiv__S__req_in2,
  output [4:0]   _reg_signals_MulDiv__M__MulDiv__S__req_tag,
  output         _reg_signals_MulDiv__M__MulDiv__S__resHi,
  output [2:0]   _reg_signals_MulDiv__M__MulDiv__S__state
);

  wire         _io_req_ready_output;
  wire         _io_resp_valid_output;
  wire [2:0]   decoded_plaInput;
  reg  [2:0]   state;
  reg  [4:0]   req_fn;
  reg          req_dw;
  reg  [63:0]  req_in1;
  reg  [63:0]  req_in2;
  reg  [4:0]   req_tag;
  reg  [6:0]   count;
  reg          neg_out;
  reg          isHi;
  reg          resHi;
  reg  [64:0]  divisor;
  reg  [129:0] remainder;
  wire [2:0]   decoded_invInputs = ~decoded_plaInput;
  wire [1:0]   _decoded_T_2 = {decoded_invInputs[1], decoded_invInputs[2]};
  wire [1:0]   _decoded_orMatrixOutputs_T_4 =
    {&{io_req_bits_fn[0], decoded_invInputs[2]}, io_req_bits_fn[1]};
  assign decoded_plaInput = io_req_bits_fn[2:0];
  wire         lhs_sign =
    (|{decoded_invInputs[0], &_decoded_T_2})
    & (io_req_bits_dw ? io_req_bits_in1[63] : io_req_bits_in1[31]);
  wire         rhs_sign =
    (|{&_decoded_T_2, &{decoded_invInputs[0], io_req_bits_fn[2]}})
    & (io_req_bits_dw ? io_req_bits_in2[63] : io_req_bits_in2[31]);
  wire [64:0]  _subtractor_T_1 = remainder[128:64] - divisor;
  wire [63:0]  result = resHi ? remainder[128:65] : remainder[63:0];
  wire         _GEN = state == 3'h1;
  wire         _GEN_0 = state == 3'h5;
  wire         _GEN_1 = state == 3'h2;
  wire         _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_16 = count == 7'h3F;
  wire         _GEN_2 = state == 3'h3;
  wire         _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_18 = count == 7'h40;
  wire         _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_20 =
    count == 7'h0 & ~(_subtractor_T_1[64]) & ~isHi;
  wire         _GEN_3 = io_resp_ready & _io_resp_valid_output | io_kill;
  wire         _GEN_4 = _io_req_ready_output & io_req_valid;
  wire         _mux_cond_prop_wire_MulDiv__M__MulDiv__S___state_T_1 = lhs_sign | rhs_sign;
  wire         _mux_cond_prop_wire_MulDiv__M__MulDiv__S___count_T_6 =
    decoded_invInputs[2] & ~io_req_bits_dw;
  wire         _loOut_T_3 = ~req_dw & ~(state[0]);
  wire [31:0]  loOut = _loOut_T_3 ? result[63:32] : result[31:0];
  assign _io_resp_valid_output = state == 3'h6 | (&state);
  assign _io_req_ready_output = state == 3'h0;
  always @(posedge clock) begin
    automatic logic _GEN_5;
    _GEN_5 = _GEN_1 & _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_16;
    if (reset)
      state <= 3'h0;
    else if (_GEN_4) begin
      if (decoded_invInputs[2])
        state <= 3'h2;
      else
        state <= {1'h0, ~_mux_cond_prop_wire_MulDiv__M__MulDiv__S___state_T_1, 1'h1};
    end
    else if (_GEN_3)
      state <= 3'h0;
    else if (_GEN_2 & _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_18)
      state <= {1'h1, ~neg_out, 1'h1};
    else if (_GEN_5)
      state <= 3'h6;
    else if (_GEN_0)
      state <= 3'h7;
    else if (_GEN)
      state <= 3'h3;
    if (_GEN_4) begin
      req_fn <= io_req_bits_fn;
      req_dw <= io_req_bits_dw;
      req_in1 <= io_req_bits_in1;
      req_in2 <= io_req_bits_in2;
      req_tag <= io_req_bits_tag;
      count <= {1'h0, _mux_cond_prop_wire_MulDiv__M__MulDiv__S___count_T_6, 5'h0};
      if (|_decoded_orMatrixOutputs_T_4)
        neg_out <= lhs_sign;
      else
        neg_out <= lhs_sign != rhs_sign;
      isHi <= |_decoded_orMatrixOutputs_T_4;
      divisor <=
        {rhs_sign,
         io_req_bits_dw ? io_req_bits_in2[63:32] : {32{rhs_sign}},
         io_req_bits_in2[31:0]};
      remainder <=
        {66'h0,
         io_req_bits_dw ? io_req_bits_in1[63:32] : {32{lhs_sign}},
         io_req_bits_in1[31:0]};
    end
    else begin
      if (_GEN_2) begin
        count <= count + 7'h1;
        remainder <=
          {1'h0,
           _subtractor_T_1[64] ? remainder[127:64] : _subtractor_T_1[63:0],
           remainder[63:0],
           ~(_subtractor_T_1[64])};
      end
      else if (_GEN_1) begin
        automatic logic [65:0] _prod_T_4 =
          {{65{remainder[64]}}, remainder[0]} * {divisor[64], divisor}
          + {remainder[129], remainder[129:65]};
        count <= count + 7'h1;
        remainder <=
          {_prod_T_4[65:1], count == 7'h3E & neg_out, _prod_T_4[0], remainder[63:1]};
      end
      else if (_GEN_0 | _GEN & remainder[63])
        remainder <= {66'h0, 64'h0 - result};
      neg_out <= ~(_GEN_2 & _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_20) & neg_out;
      if (_GEN & divisor[63])
        divisor <= _subtractor_T_1;
    end
    resHi <=
      ~_GEN_4
      & (_GEN_2 & _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_18 | _GEN_5
           ? isHi
           : ~_GEN_0 & resHi);
  end // always @(posedge)
  assign io_req_ready = _io_req_ready_output;
  assign io_resp_valid = _io_resp_valid_output;
  assign io_resp_bits_data = {req_dw ? result[63:32] : {32{loOut[31]}}, loOut};
  assign io_resp_bits_full_data = {remainder[128:65], remainder[63:0]};
  assign io_resp_bits_tag = req_tag;
  assign _mux_cond_MulDiv__M__MulDiv__S___T_5 = ~io_req_bits_dw;
  assign _mux_cond_MulDiv__M__MulDiv__S___T_8 = ~io_req_bits_dw;
  assign _mux_cond_MulDiv__M__MulDiv__S___count_T_6 =
    _mux_cond_prop_wire_MulDiv__M__MulDiv__S___count_T_6;
  assign _mux_cond_MulDiv__M__MulDiv__S___hiOut_T_1 = ~req_dw;
  assign _mux_cond_MulDiv__M__MulDiv__S___hiOut_T_3 = loOut[31];
  assign _mux_cond_MulDiv__M__MulDiv__S___hi_T = lhs_sign;
  assign _mux_cond_MulDiv__M__MulDiv__S___hi_T_3 = rhs_sign;
  assign _mux_cond_MulDiv__M__MulDiv__S___loOut_T_3 = _loOut_T_3;
  assign _mux_cond_MulDiv__M__MulDiv__S___state_T_1 =
    _mux_cond_prop_wire_MulDiv__M__MulDiv__S___state_T_1;
  assign _mux_cond_MulDiv__M__MulDiv__S__cmdHi = |_decoded_orMatrixOutputs_T_4;
  assign _mux_cond_MulDiv__M__MulDiv__S__cmdMul = decoded_invInputs[2];
  assign _mux_cond_MulDiv__M__MulDiv__S__eOut = 1'h0;
  assign _mux_cond_MulDiv__M__MulDiv__S__neg_out = neg_out;
  assign _mux_cond_MulDiv__M__MulDiv__S__resHi = resHi;
  assign _mux_cond_MulDiv__M__MulDiv__S__unrolls_less = _subtractor_T_1[64];
  assign _cond_pred_MulDiv__M__MulDiv__S___T_10 = _GEN;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_11 = remainder[63];
  assign _cond_pred_MulDiv__M__MulDiv__S___T_12 = divisor[63];
  assign _cond_pred_MulDiv__M__MulDiv__S___T_13 = _GEN_0;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_14 = _GEN_1;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_16 =
    _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_16;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_17 = _GEN_2;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_18 =
    _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_18;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_20 =
    _cond_pred_prop_wire_MulDiv__M__MulDiv__S___T_20;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_22 = _GEN_3;
  assign _cond_pred_MulDiv__M__MulDiv__S___T_23 = _GEN_4;
  assign _reg_signals_MulDiv__M__MulDiv__S__count = count;
  assign _reg_signals_MulDiv__M__MulDiv__S__divisor = divisor;
  assign _reg_signals_MulDiv__M__MulDiv__S__isHi = isHi;
  assign _reg_signals_MulDiv__M__MulDiv__S__neg_out = neg_out;
  assign _reg_signals_MulDiv__M__MulDiv__S__remainder = remainder;
  assign _reg_signals_MulDiv__M__MulDiv__S__req_fn = req_fn;
  assign _reg_signals_MulDiv__M__MulDiv__S__req_dw = req_dw;
  assign _reg_signals_MulDiv__M__MulDiv__S__req_in1 = req_in1;
  assign _reg_signals_MulDiv__M__MulDiv__S__req_in2 = req_in2;
  assign _reg_signals_MulDiv__M__MulDiv__S__req_tag = req_tag;
  assign _reg_signals_MulDiv__M__MulDiv__S__resHi = resHi;
  assign _reg_signals_MulDiv__M__MulDiv__S__state = state;
endmodule

