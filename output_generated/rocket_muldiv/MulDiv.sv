// Generated by CIRCT firtool-1.43.0
module MulDiv(
  input          clock,
                 reset,
                 io_req_valid,
  input  [4:0]   io_req_bits_fn,
  input          io_req_bits_dw,
  input  [63:0]  io_req_bits_in1,
                 io_req_bits_in2,
  input  [4:0]   io_req_bits_tag,
  input          io_kill,
                 io_resp_ready,
  output         io_req_ready,
                 io_resp_valid,
  output [63:0]  io_resp_bits_data,
  output [127:0] io_resp_bits_full_data,
  output [4:0]   io_resp_bits_tag,
  output         _mc__s0,
                 _mc__s1,
                 _mc__s10,
                 _mc__s11,
                 _mc__s12,
                 _mc__s13,
                 _mc__s14,
                 _mc__s2,
                 _mc__s3,
                 _mc__s4,
                 _mc__s5,
                 _mc__s6,
                 _mc__s7,
                 _mc__s8,
                 _mc__s9,
                 _cp__s0,
                 _cp__s1,
                 _cp__s10,
                 _cp__s2,
                 _cp__s3,
                 _cp__s4,
                 _cp__s5,
                 _cp__s6,
                 _cp__s7,
                 _cp__s8,
                 _cp__s9,
  output [2:0]   _rs__s0,
  output [4:0]   _rs__s1,
  output [64:0]  _rs__s10,
  output [129:0] _rs__s11,
  output         _rs__s2,
  output [63:0]  _rs__s3,
                 _rs__s4,
  output [4:0]   _rs__s5,
  output [6:0]   _rs__s6,
  output         _rs__s7,
                 _rs__s8,
                 _rs__s9
);

  wire         _io_req_ready_output;
  wire         _io_resp_valid_output;
  wire [2:0]   decoded_plaInput;
  reg  [2:0]   state;
  reg  [4:0]   req_fn;
  reg          req_dw;
  reg  [63:0]  req_in1;
  reg  [63:0]  req_in2;
  reg  [4:0]   req_tag;
  reg  [6:0]   count;
  reg          neg_out;
  reg          isHi;
  reg          resHi;
  reg  [64:0]  divisor;
  reg  [129:0] remainder;
  wire [2:0]   decoded_invInputs = ~decoded_plaInput;
  wire [1:0]   _GEN = {decoded_invInputs[1], decoded_invInputs[2]};
  wire [1:0]   _GEN_0 = {&{io_req_bits_fn[0], decoded_invInputs[2]}, io_req_bits_fn[1]};
  assign decoded_plaInput = io_req_bits_fn[2:0];
  wire         lhs_sign =
    (|{decoded_invInputs[0], &_GEN})
    & (io_req_bits_dw ? io_req_bits_in1[63] : io_req_bits_in1[31]);
  wire         rhs_sign =
    (|{&_GEN, &{decoded_invInputs[0], io_req_bits_fn[2]}})
    & (io_req_bits_dw ? io_req_bits_in2[63] : io_req_bits_in2[31]);
  wire [64:0]  subtractor = remainder[128:64] - divisor;
  wire [63:0]  result = resHi ? remainder[128:65] : remainder[63:0];
  wire         _GEN_1 = state == 3'h1;
  wire         _GEN_2 = state == 3'h5;
  wire         _GEN_3 = state == 3'h2;
  wire         _GEN_4 = count == 7'h3F;
  wire         _GEN_5 = state == 3'h3;
  wire         _GEN_6 = count == 7'h40;
  wire         _GEN_7 = count == 7'h0 & ~(subtractor[64]) & ~isHi;
  wire         _GEN_8 = io_resp_ready & _io_resp_valid_output | io_kill;
  wire         _GEN_9 = _io_req_ready_output & io_req_valid;
  wire         _GEN_10 = lhs_sign | rhs_sign;
  wire         _GEN_11 = decoded_invInputs[2] & ~io_req_bits_dw;
  wire         _GEN_12 = ~req_dw & ~(state[0]);
  wire [31:0]  loOut = _GEN_12 ? result[63:32] : result[31:0];
  assign _io_resp_valid_output = state == 3'h6 | (&state);
  assign _io_req_ready_output = state == 3'h0;
  always @(posedge clock) begin
    automatic logic _GEN_13;
    _GEN_13 = _GEN_3 & _GEN_4;
    if (reset)
      state <= 3'h0;
    else if (_GEN_9) begin
      if (decoded_invInputs[2])
        state <= 3'h2;
      else
        state <= {1'h0, ~_GEN_10, 1'h1};
    end
    else if (_GEN_8)
      state <= 3'h0;
    else if (_GEN_5 & _GEN_6)
      state <= {1'h1, ~neg_out, 1'h1};
    else if (_GEN_13)
      state <= 3'h6;
    else if (_GEN_2)
      state <= 3'h7;
    else if (_GEN_1)
      state <= 3'h3;
    if (_GEN_9) begin
      req_fn <= io_req_bits_fn;
      req_dw <= io_req_bits_dw;
      req_in1 <= io_req_bits_in1;
      req_in2 <= io_req_bits_in2;
      req_tag <= io_req_bits_tag;
      count <= {1'h0, _GEN_11, 5'h0};
      if (|_GEN_0)
        neg_out <= lhs_sign;
      else
        neg_out <= lhs_sign != rhs_sign;
      isHi <= |_GEN_0;
      divisor <=
        {rhs_sign,
         io_req_bits_dw ? io_req_bits_in2[63:32] : {32{rhs_sign}},
         io_req_bits_in2[31:0]};
      remainder <=
        {66'h0,
         io_req_bits_dw ? io_req_bits_in1[63:32] : {32{lhs_sign}},
         io_req_bits_in1[31:0]};
    end
    else begin
      if (_GEN_5 | _GEN_3)
        count <= count + 7'h1;
      neg_out <= ~(_GEN_5 & _GEN_7) & neg_out;
      if (_GEN_1 & divisor[63])
        divisor <= subtractor;
      if (_GEN_5)
        remainder <=
          {1'h0,
           subtractor[64] ? remainder[127:64] : subtractor[63:0],
           remainder[63:0],
           ~(subtractor[64])};
      else if (_GEN_3) begin
        automatic logic [65:0] _GEN_14 =
          {{65{remainder[64]}}, remainder[0]} * {divisor[64], divisor}
          + {remainder[129], remainder[129:65]};
        remainder <=
          {_GEN_14[65:1], count == 7'h3E & neg_out, _GEN_14[0], remainder[63:1]};
      end
      else if (_GEN_2 | _GEN_1 & remainder[63])
        remainder <= {66'h0, 64'h0 - result};
    end
    resHi <= ~_GEN_9 & (_GEN_5 & _GEN_6 | _GEN_13 ? isHi : ~_GEN_2 & resHi);
  end // always @(posedge)
  assign io_req_ready = _io_req_ready_output;
  assign io_resp_valid = _io_resp_valid_output;
  assign io_resp_bits_data = {req_dw ? result[63:32] : {32{loOut[31]}}, loOut};
  assign io_resp_bits_full_data = {remainder[128:65], remainder[63:0]};
  assign io_resp_bits_tag = req_tag;
  assign _mc__s0 = ~io_req_bits_dw;
  assign _mc__s1 = lhs_sign;
  assign _mc__s10 = _GEN_11;
  assign _mc__s11 = |_GEN_0;
  assign _mc__s12 = _GEN_12;
  assign _mc__s13 = loOut[31];
  assign _mc__s14 = ~req_dw;
  assign _mc__s2 = ~io_req_bits_dw;
  assign _mc__s3 = rhs_sign;
  assign _mc__s4 = resHi;
  assign _mc__s5 = 1'h0;
  assign _mc__s6 = subtractor[64];
  assign _mc__s7 = neg_out;
  assign _mc__s8 = _GEN_10;
  assign _mc__s9 = decoded_invInputs[2];
  assign _cp__s0 = _GEN_1;
  assign _cp__s1 = remainder[63];
  assign _cp__s10 = _GEN_9;
  assign _cp__s2 = divisor[63];
  assign _cp__s3 = _GEN_2;
  assign _cp__s4 = _GEN_3;
  assign _cp__s5 = _GEN_4;
  assign _cp__s6 = _GEN_5;
  assign _cp__s7 = _GEN_6;
  assign _cp__s8 = _GEN_7;
  assign _cp__s9 = _GEN_8;
  assign _rs__s0 = state;
  assign _rs__s1 = req_fn;
  assign _rs__s10 = divisor;
  assign _rs__s11 = remainder;
  assign _rs__s2 = req_dw;
  assign _rs__s3 = req_in1;
  assign _rs__s4 = req_in2;
  assign _rs__s5 = req_tag;
  assign _rs__s6 = count;
  assign _rs__s7 = neg_out;
  assign _rs__s8 = isHi;
  assign _rs__s9 = resHi;
endmodule

