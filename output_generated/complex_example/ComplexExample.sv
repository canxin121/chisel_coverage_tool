// Generated by CIRCT firtool-1.51.0
module SubModule(
  input        clock,
               reset,
  input  [7:0] io_a,
               io_b,
  input  [1:0] io_sel,
  output [7:0] io_out,
  output       _cond_pred_ComplexExample__I__sub__M__SubModule__S___T,
               _cond_pred_ComplexExample__I__sub__M__SubModule__S___T_1,
               _cond_pred_ComplexExample__I__sub__M__SubModule__S___T_2,
  output [7:0] _reg_signals_ComplexExample__I__sub__M__SubModule__S__stateReg
);

  reg  [7:0]      stateReg;
  wire [3:0][7:0] _GEN = {{stateReg}, {stateReg + 8'h1}, {io_b}, {io_a}};
  always @(posedge clock) begin
    if (reset)
      stateReg <= 8'h0;
    else begin
      automatic logic [3:0][7:0] _GEN_0 =
        {{stateReg}, {io_a & io_b}, {io_a - io_b}, {io_a + io_b}};
      stateReg <= _GEN_0[io_sel];
    end
  end // always @(posedge)
  assign io_out = _GEN[io_sel];
  assign _cond_pred_ComplexExample__I__sub__M__SubModule__S___T = io_sel == 2'h0;
  assign _cond_pred_ComplexExample__I__sub__M__SubModule__S___T_1 = io_sel == 2'h1;
  assign _cond_pred_ComplexExample__I__sub__M__SubModule__S___T_2 = io_sel == 2'h2;
  assign _reg_signals_ComplexExample__I__sub__M__SubModule__S__stateReg = stateReg;
endmodule

module AnotherSubModule(
  input        clock,
               reset,
  input  [7:0] io_in,
  output [7:0] io_out,
  output       _cond_pred_ComplexExample__I__anotherSub__M__AnotherSubModule__S___T,
  output [7:0] _reg_signals_ComplexExample__I__anotherSub__M__AnotherSubModule__S__delayedIn
);

  reg  [7:0] delayedIn;
  wire       _GEN = io_in > 8'h64;
  always @(posedge clock) begin
    if (reset)
      delayedIn <= 8'h0;
    else
      delayedIn <= io_in;
  end // always @(posedge)
  assign io_out = _GEN ? delayedIn + 8'h1 : delayedIn;
  assign _cond_pred_ComplexExample__I__anotherSub__M__AnotherSubModule__S___T = _GEN;
  assign _reg_signals_ComplexExample__I__anotherSub__M__AnotherSubModule__S__delayedIn =
    delayedIn;
endmodule

module ComplexExample(
  input        clock,
               reset,
  input  [7:0] io_topInA,
               io_topInB,
  input  [1:0] io_topSel,
  output [7:0] io_topOut,
  output       _mux_cond_ComplexExample__M__ComplexExample__S___anotherSub_io_in_T,
               _mux_cond_ComplexExample__M__ComplexExample__S___sub_io_a_T,
               _cond_pred_ComplexExample__I__anotherSub__M__AnotherSubModule__S___T,
               _cond_pred_ComplexExample__I__sub__M__SubModule__S___T,
               _cond_pred_ComplexExample__I__sub__M__SubModule__S___T_1,
               _cond_pred_ComplexExample__I__sub__M__SubModule__S___T_2,
               _cond_pred_ComplexExample__M__ComplexExample__S___T,
               _cond_pred_ComplexExample__M__ComplexExample__S___T_1,
               _cond_pred_ComplexExample__M__ComplexExample__S___T_2,
               _cond_pred_ComplexExample__M__ComplexExample__S___T_3,
  output [7:0] _reg_signals_ComplexExample__I__anotherSub__M__AnotherSubModule__S__delayedIn,
               _reg_signals_ComplexExample__I__sub__M__SubModule__S__stateReg
);

  wire [7:0]      _anotherSub_io_out;
  wire [7:0]      _sub_io_out;
  wire [3:0][7:0] _GEN =
    {{8'h0}, {io_topInA + io_topInB}, {_sub_io_out}, {_anotherSub_io_out}};
  SubModule sub (
    .clock                                                          (clock),
    .reset                                                          (reset),
    .io_a
      (io_topSel[0] ? io_topInB : io_topInA),
    .io_b
      (io_topSel[1] ? io_topInA : io_topInB),
    .io_sel                                                         (io_topSel),
    .io_out                                                         (_sub_io_out),
    ._cond_pred_ComplexExample__I__sub__M__SubModule__S___T
      (_cond_pred_ComplexExample__I__sub__M__SubModule__S___T),
    ._cond_pred_ComplexExample__I__sub__M__SubModule__S___T_1
      (_cond_pred_ComplexExample__I__sub__M__SubModule__S___T_1),
    ._cond_pred_ComplexExample__I__sub__M__SubModule__S___T_2
      (_cond_pred_ComplexExample__I__sub__M__SubModule__S___T_2),
    ._reg_signals_ComplexExample__I__sub__M__SubModule__S__stateReg
      (_reg_signals_ComplexExample__I__sub__M__SubModule__S__stateReg)
  );
  AnotherSubModule anotherSub (
    .clock
      (clock),
    .reset
      (reset),
    .io_in
      (io_topSel[0] ? _sub_io_out : io_topInA),
    .io_out
      (_anotherSub_io_out),
    ._cond_pred_ComplexExample__I__anotherSub__M__AnotherSubModule__S___T
      (_cond_pred_ComplexExample__I__anotherSub__M__AnotherSubModule__S___T),
    ._reg_signals_ComplexExample__I__anotherSub__M__AnotherSubModule__S__delayedIn
      (_reg_signals_ComplexExample__I__anotherSub__M__AnotherSubModule__S__delayedIn)
  );
  assign io_topOut = _GEN[io_topSel];
  assign _mux_cond_ComplexExample__M__ComplexExample__S___anotherSub_io_in_T =
    io_topSel[0];
  assign _mux_cond_ComplexExample__M__ComplexExample__S___sub_io_a_T = io_topSel[0];
  assign _cond_pred_ComplexExample__M__ComplexExample__S___T = io_topSel[1];
  assign _cond_pred_ComplexExample__M__ComplexExample__S___T_1 = io_topSel == 2'h0;
  assign _cond_pred_ComplexExample__M__ComplexExample__S___T_2 = io_topSel == 2'h1;
  assign _cond_pred_ComplexExample__M__ComplexExample__S___T_3 = io_topSel == 2'h2;
endmodule

