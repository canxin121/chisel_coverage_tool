// Generated by CIRCT firtool-1.51.0
module SubModule(
  input        clock,
               reset,
  input  [7:0] io_a,
               io_b,
  input  [1:0] io_sel,
  output [7:0] io_out
);

  reg  [7:0]      stateReg;
  wire [3:0][7:0] _GEN = {{stateReg}, {stateReg + 8'h1}, {io_b}, {io_a}};
  always @(posedge clock) begin
    if (reset)
      stateReg <= 8'h0;
    else begin
      automatic logic [3:0][7:0] _GEN_0 =
        {{stateReg}, {io_a & io_b}, {io_a - io_b}, {io_a + io_b}};
      stateReg <= _GEN_0[io_sel];
    end
  end // always @(posedge)
  assign io_out = _GEN[io_sel];
endmodule

module AnotherSubModule(
  input        clock,
               reset,
  input  [7:0] io_in,
  output [7:0] io_out
);

  reg [7:0] delayedIn;
  always @(posedge clock) begin
    if (reset)
      delayedIn <= 8'h0;
    else
      delayedIn <= io_in;
  end // always @(posedge)
  assign io_out = io_in > 8'h64 ? delayedIn + 8'h1 : delayedIn;
endmodule

module ComplexExample(
  input        clock,
               reset,
  input  [7:0] io_topInA,
               io_topInB,
  input  [1:0] io_topSel,
  output [7:0] io_topOut
);

  wire [7:0]      _anotherSub_io_out;
  wire [7:0]      _sub_io_out;
  wire [3:0][7:0] _GEN =
    {{8'h0}, {io_topInA + io_topInB}, {_sub_io_out}, {_anotherSub_io_out}};
  SubModule sub (
    .clock  (clock),
    .reset  (reset),
    .io_a   (io_topSel[0] ? io_topInB : io_topInA),
    .io_b   (io_topSel[1] ? io_topInA : io_topInB),
    .io_sel (io_topSel),
    .io_out (_sub_io_out)
  );
  AnotherSubModule anotherSub (
    .clock  (clock),
    .reset  (reset),
    .io_in  (io_topSel[0] ? _sub_io_out : io_topInA),
    .io_out (_anotherSub_io_out)
  );
  assign io_topOut = _GEN[io_topSel];
endmodule

